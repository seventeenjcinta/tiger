%{
#include <stdio.h>
#include "util.h"
#include "errormsg.h"

int yylex(void); /* function prototype */

A_exp absyn_root;

void yyerror(char *s)
{
 EM_error(EM_tokPos, "%s", s);
}
%}


%union {
	int pos;
	int ival;
	string sval;
	A_exp exp
	}

%token <sval> ID STRING
%token <ival> INT

%token 
  COMMA COLON SEMICOLON LPAREN RPAREN LBRACK RBRACK 
  LBRACE RBRACE DOT 
  ADD SUB MUL DIV EQ NEQ LT LT_EQ GT GT_EQ
  AND OR ASSIGN
  ARRAY IF THEN ELSE WHILE FOR TO DO LET IN END OF 
  BREAK NIL
  FUNCTION VAR TYPE

%type <exp> program main expr

%nonassoc THEN DO TYPE FUNCTION ID
%nonassoc ASSIGN LBRACK ELSE OF COMMA
%left OR
%left AND
%nonassoc EQ NEQ LT_EQ LT GT GT_EQ
%left ADD SUB
%left MUL DIV
%left USUB

%start program

%%

program : main { absyn_root = $1; };

main
    : /* Empty */ { $$ = NULL; }
    | expr  { $$ = $1; }
    ;

expr
    : INT   { $$ = A_IntExp(EM_tokPos, $1); }
    | STRING    { $$ = A_StringExp(EM_tokPos, $1); }
    | NIL   { $$ = A_NilExp(EM_tokPos); }
    | lvalue    { $$ = A_VarExp(EM_tokPos, $1); }
    | SUB expr %prec USUB       { $$ = A_OpExp(EM_tokPos, A_minusOp, A_IntExp(EM_tokPos, 0), $2); }
    | expr ADD expr     { $$ = A_OpExp(EM_tokPos, A_plusOp, $1, $3); }
    | expr SUB expr     { $$ = A_OpExp(EM_tokPos, A_minusOp, $1, $3); }
    | expr MUL expr     { $$ = A_OpExp(EM_tokPos, A_timesOp, $1, $3); }
    | expr DIV expr     { $$ = A_OpExp(EM_tokPos, A_divideOp, $1, $3); }
    | expr EQ expr      { $$ = A_OpExp(EM_tokPos, A_eqOp, $1, $3); }
    | expr NEQ expr     { $$ = A_OpExp(EM_tokPos, A_neqOp, $1, $3); }
    | expr LT expr      { $$ = A_OpExp(EM_tokPos, A_ltOp, $1, $3); }
    | expr LT_EQ expr   { $$ = A_OpExp(EM_tokPos, A_leOp, $1, $3); }
    | expr GT expr      { $$ = A_OpExp(EM_tokPos, A_gtOp, $1, $3); }
    | expr GT_EQ expr   { $$ = A_OpExp(EM_tokPos, A_geOp, $1, $3); }
    | expr AND expr     { $$ = A_IfExp(EM_tokPos, $1, $3, A_IntExp(EM_tokPos, 0)); }
    | expr OR expr      { $$ = A_IfExp(EM_tokPos, $1, A_IntExp(EM_tokPos, 1), $3); }
    | lvalue ASSIGN expr    { $$ = A_AssignExp(EM_tokPos, $1, $3); }
    | id LPAREN expr_list_opt RPAREN    { $$ = A_CallExp(EM_tokPos, $1, $3); }
    | LPAREN expr_seq_opt RPAREN    { $$ = A_SeqExp(EM_tokPos, $2); }
    | id LBRACE field_list_opt RBRACE   { $$ = A_RecordExp(EM_tokPos, $1, $3); }
    | id LBRACK expr RBRACK OF expr     { $$ = A_ArrayExp(EM_tokPos, ); }
    | IF expr THEN expr { $$ = A_IfExp(EM_tokPos, $2, $4, ); }
    | IF expr THEN expr ELSE expr
    | WHILE expr DO expr
    | FOR id ASSIGN expr TO expr DO expr
    | BREAK
    | LET declaration_list IN expr_seq_opt END
    ;

lvalue
    : id
    | lvalue DOT id
    | id LBRACK expr RBRACK
    ;


id  : ID ;

type_id
    : STRING
    | INT
    | ID
    ;

expr_list_opt
    : /* Empty */
    | expr_list
    ;

expr_list
    : expr
    | expr_list COMMA expr
    ;

expr_seq_opt
    : /* Empty */
    | expr_seq
    ;

expr_seq
    : expr
    | expr_seq SEMICOLON expr
    ;

field_list_opt
    : /* Empty */
    | field_list
    ;

field_list
    : id EQ expr
    | field_list COMMA id EQ expr
    ;

declaration_list
    : declaration
    | declaration_list declaration
    ;

declaration
    : type_declaration
    | variable_declaration
    | function_declaration
    ;

type_declaration
    : TYPE id EQ type
    ;

type
    : id
    | LBRACE type_fields_opt RBRACE
    | ARRAY OF id
    ;

type_fields_opt
    : /* Empty */
    | type_fields
    ;

type_fields
    : type_field
    | type_fields COMMA type_field
    ;

type_field
    : id COLON id
    ;

variable_declaration
    : VAR id ASSIGN expr
    | VAR id COLON id ASSIGN expr
    ;

function_declaration
    : FUNCTION id LPAREN type_fields_opt RPAREN EQ expr
    | FUNCTION id LPAREN type_fields_opt RPAREN COLON type_id EQ expr
    ;
